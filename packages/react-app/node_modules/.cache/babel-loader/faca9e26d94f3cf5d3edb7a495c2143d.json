{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { providers } from 'ethers';\nimport { getAddress } from 'ethers/lib/utils';\nimport { createContext, useCallback, useContext, useEffect, useState } from 'react';\nimport { useConfig, useLocalStorage, useReadonlyNetwork } from '../../../hooks';\nimport { useReadonlyNetworkStates } from '../readonlyNetworks/context';\nimport { ConnectorController } from './connectorController';\nimport { InjectedConnector } from './implementations';\nconst Provider = providers.Provider;\nconst getAccount = connector => {\n  if (connector === null || connector === void 0 ? void 0 : connector.accounts[0]) {\n    return getAddress(connector.accounts[0]);\n  }\n  return undefined;\n};\nexport const ConnectorContext = createContext({\n  connector: undefined,\n  //eslint-disable-next-line @typescript-eslint/no-empty-function\n  activate: async () => {},\n  //eslint-disable-next-line @typescript-eslint/no-empty-function\n  deactivate: () => {},\n  //eslint-disable-next-line @typescript-eslint/no-empty-function\n  activateBrowserWallet: () => {},\n  //eslint-disable-next-line @typescript-eslint/no-empty-function\n  reportError: () => {},\n  isLoading: false,\n  setError: () => {\n    throw new Error('Function not implemented.');\n  },\n  active: false,\n  switchNetwork: () => {\n    throw new Error('Function not implemented.');\n  }\n});\nexport function ConnectorContextProvider(_ref) {\n  let {\n    children\n  } = _ref;\n  var _a;\n  const [controller, setController] = useState();\n  const [isLoading, setLoading] = useState(false);\n  const config = useConfig();\n  const {\n    connectors,\n    autoConnect\n  } = config;\n  const [autoConnectTag, setAutoConnectTag] = useLocalStorage('usedapp:autoConnectTag');\n  const activate = useCallback(async function (providerOrConnector) {\n    let {\n      silently,\n      onSuccess\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      silently: false\n    };\n    let controller;\n    if ('activate' in providerOrConnector) {\n      controller = new ConnectorController(providerOrConnector, config);\n    } else {\n      const wrappedProvider = Provider.isProvider(providerOrConnector) ? providerOrConnector : new providers.Web3Provider(providerOrConnector);\n      controller = new ConnectorController(new InjectedConnector(wrappedProvider), config);\n    }\n    setLoading(true);\n    setController(controller);\n    try {\n      if (silently) {\n        await controller.activate(connector => connector.connectEagerly());\n      } else {\n        await controller.activate();\n      }\n      setLoading(false);\n      onSuccess === null || onSuccess === void 0 ? void 0 : onSuccess();\n    } catch (error) {\n      controller.reportError(error);\n    } finally {\n      setLoading(false);\n    }\n  }, [setController, setLoading]);\n  const activateBrowserWallet = useCallback(async options => {\n    // done for backward compatibility.\n    // If the options object looks like an event object or is undefined,\n    // it's not a valid option and will be ignored\n    if (!options || typeof options.preventDefault === 'function') {\n      options = {\n        type: 'metamask'\n      };\n    }\n    const {\n      type\n    } = options;\n    if (!connectors[type]) {\n      throw new Error(`Connector ${type} is not configured`);\n    }\n    await activate(connectors[type], {\n      onSuccess: () => {\n        setAutoConnectTag(type);\n      }\n    });\n  }, [activate, setAutoConnectTag, connectors]);\n  const deactivate = useCallback(async () => {\n    setAutoConnectTag(undefined);\n    setLoading(true);\n    setController(undefined);\n    await (controller === null || controller === void 0 ? void 0 : controller.deactivate());\n    setLoading(false);\n  }, [controller]);\n  const reportError = useCallback(err => {\n    controller === null || controller === void 0 ? void 0 : controller.reportError(err);\n  }, [controller]);\n  const switchNetwork = useCallback(async chainId => {\n    await (controller === null || controller === void 0 ? void 0 : controller.switchNetwork(chainId));\n  }, [controller]);\n  const setErrorDeprecated = useCallback(() => {\n    throw new Error('setError is deprecated');\n  }, []);\n  const ethersActivate = useCallback(async providerOrConnector => {\n    if ('getProvider' in providerOrConnector) {\n      console.warn('Using web3-react connectors is deprecated and may lead to unexpected behavior.');\n      await providerOrConnector.activate();\n      return activate(await providerOrConnector.getProvider());\n    }\n    return activate(providerOrConnector);\n  }, []);\n  useEffect(() => {\n    if (autoConnect && autoConnectTag && connectors[autoConnectTag]) {\n      void activate(connectors[autoConnectTag], {\n        silently: true\n      });\n    }\n  }, []);\n  useEffect(() => {\n    controller === null || controller === void 0 ? void 0 : controller.updateConfig(config);\n  }, [controller, config]);\n  const readonlyNetwork = useReadonlyNetwork();\n  const [errors, setErrors] = useState((_a = controller === null || controller === void 0 ? void 0 : controller.errors) !== null && _a !== void 0 ? _a : []);\n  const [account, setAccount] = useState(getAccount(controller));\n  const [provider, setProvider] = useState(controller === null || controller === void 0 ? void 0 : controller.getProvider());\n  const [chainId, setChainId] = useState(controller === null || controller === void 0 ? void 0 : controller.chainId);\n  useEffect(() => {\n    if (!(controller === null || controller === void 0 ? void 0 : controller.getProvider())) {\n      setAccount(undefined);\n      setProvider(readonlyNetwork === null || readonlyNetwork === void 0 ? void 0 : readonlyNetwork.provider);\n      setChainId(readonlyNetwork === null || readonlyNetwork === void 0 ? void 0 : readonlyNetwork.chainId);\n      setErrors([]);\n    } else {\n      setChainId(controller.chainId);\n      setErrors(controller.errors);\n      setProvider(controller.getProvider());\n      setAccount(getAccount(controller));\n    }\n    return controller === null || controller === void 0 ? void 0 : controller.updated.on(_ref2 => {\n      let {\n        chainId,\n        errors,\n        accounts\n      } = _ref2;\n      if (chainId) {\n        setChainId(chainId);\n        setProvider(controller.getProvider());\n        if (accounts[0]) {\n          setAccount(getAddress(accounts[0]));\n        } else {\n          setAccount(undefined);\n        }\n      }\n      setErrors([...errors]);\n    });\n  }, [controller, controller === null || controller === void 0 ? void 0 : controller.getProvider()]);\n  const {\n    networks,\n    readOnlyUrls\n  } = useConfig();\n  const [error, setError] = useState(undefined);\n  const networkStates = useReadonlyNetworkStates();\n  const configuredChainIds = Object.keys(readOnlyUrls || {}).map(chainId => parseInt(chainId, 10));\n  const supportedChainIds = networks === null || networks === void 0 ? void 0 : networks.map(network => network.chainId);\n  useEffect(() => {\n    const isNotConfiguredChainId = chainId && configuredChainIds && configuredChainIds.indexOf(chainId) < 0;\n    const isUnsupportedChainId = chainId && supportedChainIds && supportedChainIds.indexOf(chainId) < 0;\n    if (isUnsupportedChainId || isNotConfiguredChainId) {\n      const chainIdError = new Error(`${isUnsupportedChainId ? 'Unsupported' : 'Not configured'} chain id: ${chainId}.`);\n      chainIdError.name = 'ChainIdError';\n      setError(chainIdError);\n      return;\n    }\n    for (const networkState of Object.values(networkStates)) {\n      if (networkState.errors.length > 0) {\n        setError(networkState.errors[networkState.errors.length - 1]);\n        return;\n      }\n    }\n    setError(errors === null || errors === void 0 ? void 0 : errors[errors.length - 1]);\n  }, [chainId, errors, networkStates]);\n  return _jsx(ConnectorContext.Provider, Object.assign({\n    value: {\n      connector: controller,\n      deactivate,\n      reportError,\n      activate: ethersActivate,\n      activateBrowserWallet,\n      isLoading,\n      account,\n      library: provider,\n      chainId: (error === null || error === void 0 ? void 0 : error.name) === 'ChainIdError' ? undefined : provider !== undefined ? chainId : readonlyNetwork === null || readonlyNetwork === void 0 ? void 0 : readonlyNetwork.chainId,\n      error,\n      active: !!provider,\n      switchNetwork,\n      setError: setErrorDeprecated\n    }\n  }, {\n    children: children\n  }));\n}\nexport const useConnector = () => useContext(ConnectorContext);","map":{"version":3,"sources":["../../../../../../src/providers/network/connectors/context.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { providers } from 'ethers';\nimport { getAddress } from 'ethers/lib/utils';\nimport { createContext, useCallback, useContext, useEffect, useState } from 'react';\nimport { useConfig, useLocalStorage, useReadonlyNetwork } from '../../../hooks';\nimport { useReadonlyNetworkStates } from '../readonlyNetworks/context';\nimport { ConnectorController } from './connectorController';\nimport { InjectedConnector } from './implementations';\nconst Provider = providers.Provider;\nconst getAccount = (connector) => {\n    if (connector === null || connector === void 0 ? void 0 : connector.accounts[0]) {\n        return getAddress(connector.accounts[0]);\n    }\n    return undefined;\n};\nexport const ConnectorContext = createContext({\n    connector: undefined,\n    //eslint-disable-next-line @typescript-eslint/no-empty-function\n    activate: async () => { },\n    //eslint-disable-next-line @typescript-eslint/no-empty-function\n    deactivate: () => { },\n    //eslint-disable-next-line @typescript-eslint/no-empty-function\n    activateBrowserWallet: () => { },\n    //eslint-disable-next-line @typescript-eslint/no-empty-function\n    reportError: () => { },\n    isLoading: false,\n    setError: () => {\n        throw new Error('Function not implemented.');\n    },\n    active: false,\n    switchNetwork: () => {\n        throw new Error('Function not implemented.');\n    },\n});\nexport function ConnectorContextProvider({ children }) {\n    var _a;\n    const [controller, setController] = useState();\n    const [isLoading, setLoading] = useState(false);\n    const config = useConfig();\n    const { connectors, autoConnect } = config;\n    const [autoConnectTag, setAutoConnectTag] = useLocalStorage('usedapp:autoConnectTag');\n    const activate = useCallback(async (providerOrConnector, { silently, onSuccess } = { silently: false }) => {\n        let controller;\n        if ('activate' in providerOrConnector) {\n            controller = new ConnectorController(providerOrConnector, config);\n        }\n        else {\n            const wrappedProvider = Provider.isProvider(providerOrConnector)\n                ? providerOrConnector\n                : new providers.Web3Provider(providerOrConnector);\n            controller = new ConnectorController(new InjectedConnector(wrappedProvider), config);\n        }\n        setLoading(true);\n        setController(controller);\n        try {\n            if (silently) {\n                await controller.activate((connector) => connector.connectEagerly());\n            }\n            else {\n                await controller.activate();\n            }\n            setLoading(false);\n            onSuccess === null || onSuccess === void 0 ? void 0 : onSuccess();\n        }\n        catch (error) {\n            controller.reportError(error);\n        }\n        finally {\n            setLoading(false);\n        }\n    }, [setController, setLoading]);\n    const activateBrowserWallet = useCallback(async (options) => {\n        // done for backward compatibility.\n        // If the options object looks like an event object or is undefined,\n        // it's not a valid option and will be ignored\n        if (!options || typeof options.preventDefault === 'function') {\n            options = { type: 'metamask' };\n        }\n        const { type } = options;\n        if (!connectors[type]) {\n            throw new Error(`Connector ${type} is not configured`);\n        }\n        await activate(connectors[type], {\n            onSuccess: () => {\n                setAutoConnectTag(type);\n            },\n        });\n    }, [activate, setAutoConnectTag, connectors]);\n    const deactivate = useCallback(async () => {\n        setAutoConnectTag(undefined);\n        setLoading(true);\n        setController(undefined);\n        await (controller === null || controller === void 0 ? void 0 : controller.deactivate());\n        setLoading(false);\n    }, [controller]);\n    const reportError = useCallback((err) => {\n        controller === null || controller === void 0 ? void 0 : controller.reportError(err);\n    }, [controller]);\n    const switchNetwork = useCallback(async (chainId) => {\n        await (controller === null || controller === void 0 ? void 0 : controller.switchNetwork(chainId));\n    }, [controller]);\n    const setErrorDeprecated = useCallback(() => {\n        throw new Error('setError is deprecated');\n    }, []);\n    const ethersActivate = useCallback(async (providerOrConnector) => {\n        if ('getProvider' in providerOrConnector) {\n            console.warn('Using web3-react connectors is deprecated and may lead to unexpected behavior.');\n            await providerOrConnector.activate();\n            return activate(await providerOrConnector.getProvider());\n        }\n        return activate(providerOrConnector);\n    }, []);\n    useEffect(() => {\n        if (autoConnect && autoConnectTag && connectors[autoConnectTag]) {\n            void activate(connectors[autoConnectTag], {\n                silently: true,\n            });\n        }\n    }, []);\n    useEffect(() => {\n        controller === null || controller === void 0 ? void 0 : controller.updateConfig(config);\n    }, [controller, config]);\n    const readonlyNetwork = useReadonlyNetwork();\n    const [errors, setErrors] = useState((_a = controller === null || controller === void 0 ? void 0 : controller.errors) !== null && _a !== void 0 ? _a : []);\n    const [account, setAccount] = useState(getAccount(controller));\n    const [provider, setProvider] = useState(controller === null || controller === void 0 ? void 0 : controller.getProvider());\n    const [chainId, setChainId] = useState(controller === null || controller === void 0 ? void 0 : controller.chainId);\n    useEffect(() => {\n        if (!(controller === null || controller === void 0 ? void 0 : controller.getProvider())) {\n            setAccount(undefined);\n            setProvider(readonlyNetwork === null || readonlyNetwork === void 0 ? void 0 : readonlyNetwork.provider);\n            setChainId(readonlyNetwork === null || readonlyNetwork === void 0 ? void 0 : readonlyNetwork.chainId);\n            setErrors([]);\n        }\n        else {\n            setChainId(controller.chainId);\n            setErrors(controller.errors);\n            setProvider(controller.getProvider());\n            setAccount(getAccount(controller));\n        }\n        return controller === null || controller === void 0 ? void 0 : controller.updated.on(({ chainId, errors, accounts }) => {\n            if (chainId) {\n                setChainId(chainId);\n                setProvider(controller.getProvider());\n                if (accounts[0]) {\n                    setAccount(getAddress(accounts[0]));\n                }\n                else {\n                    setAccount(undefined);\n                }\n            }\n            setErrors([...errors]);\n        });\n    }, [controller, controller === null || controller === void 0 ? void 0 : controller.getProvider()]);\n    const { networks, readOnlyUrls } = useConfig();\n    const [error, setError] = useState(undefined);\n    const networkStates = useReadonlyNetworkStates();\n    const configuredChainIds = Object.keys(readOnlyUrls || {}).map((chainId) => parseInt(chainId, 10));\n    const supportedChainIds = networks === null || networks === void 0 ? void 0 : networks.map((network) => network.chainId);\n    useEffect(() => {\n        const isNotConfiguredChainId = chainId && configuredChainIds && configuredChainIds.indexOf(chainId) < 0;\n        const isUnsupportedChainId = chainId && supportedChainIds && supportedChainIds.indexOf(chainId) < 0;\n        if (isUnsupportedChainId || isNotConfiguredChainId) {\n            const chainIdError = new Error(`${isUnsupportedChainId ? 'Unsupported' : 'Not configured'} chain id: ${chainId}.`);\n            chainIdError.name = 'ChainIdError';\n            setError(chainIdError);\n            return;\n        }\n        for (const networkState of Object.values(networkStates)) {\n            if (networkState.errors.length > 0) {\n                setError(networkState.errors[networkState.errors.length - 1]);\n                return;\n            }\n        }\n        setError(errors === null || errors === void 0 ? void 0 : errors[errors.length - 1]);\n    }, [chainId, errors, networkStates]);\n    return (_jsx(ConnectorContext.Provider, Object.assign({ value: {\n            connector: controller,\n            deactivate,\n            reportError,\n            activate: ethersActivate,\n            activateBrowserWallet,\n            isLoading,\n            account,\n            library: provider,\n            chainId: (error === null || error === void 0 ? void 0 : error.name) === 'ChainIdError' ? undefined : provider !== undefined ? chainId : readonlyNetwork === null || readonlyNetwork === void 0 ? void 0 : readonlyNetwork.chainId,\n            error,\n            active: !!provider,\n            switchNetwork,\n            setError: setErrorDeprecated,\n        } }, { children: children })));\n}\nexport const useConnector = () => useContext(ConnectorContext);\n//# sourceMappingURL=context.js.map"]},"metadata":{},"sourceType":"module"}